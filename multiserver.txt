// .Magma

clear;

//__________________________assignment of  E_________________________________        //in pre-processing
m_set:=[4,5,6,7,9,11,13,16,20,25,31,38,48,60,75,94,118,148,186];
                           //m_set:  n=2^2, 2^3, ... 2^20, the set of u such that $u\choose d$ \geq n, where d=3;
                           
k:=2;	          d:=2*k-1;                     Eset:=[];
for npower in [2..20]  do 
      	n:=2^npower;        m:=m_set[npower -1];          
				//  *********main parameter*********
	E:=[];        ST:={i: i in [1..m] };        stre:=Subsets(ST,d);        num:=1;
	for iset in stre do
	     E[num]:=[0: id in [1..m]];
	     for j in iset do       
	          E[num][j]:=1;
	     end for;
 	     num:=num+1;
	     if num gt n then
	        break;
	    end if;
	end for;
  
  Eset[npower -1]:=E;       delete num,ST,stre,E;           
end for;
//_____________________________________________________________________________




//__________________________________FUNCTION F_________________________________                  
function F(z,X,E)  
                        // the input X is a database, E is the binary vector with Hamming weight being d=3
                        // z is a vector in the certain field      //ex: z:=FunctionField(gq,m);
ans:=0;                 
for i in [1..#X] do  
      prd:=1;
      for j in [1..#E[i]] do
            if E[i][j] eq 1 then
                 prd:= prd*z.j;
            end if;
      end for;
      ans:= ans+X[i]*prd;      
end for;

return ans;                
end function;
//______________________________________________________________________________






pirwy:=function(query_index,X,E,Fz)                                          //basic PIR scheme
//____________________________________INPUT______________________________________
n:=#X;        k:=2;       d:=2*k-1;       t:=1;     
npower:=Ceiling(Log(2,n));
m_set:=[4,5,6,7,9,11,13,16,20,25,31,38,48,60,75,94,118,148,186];
if npower in [2..20] then
      m:=m_set[npower-1];                         //  layers of thr Merkle tree
end if;                                          

//_________________________________pre-processing________________________________ 
q:=NextPrime(2^256);           Vq:=VectorSpace(GF(q),m);    
lamda:=[ ];
for i in [1..k] do
      lamdi:=Random(GF(q));
      while lamdi in lamda or lamdi eq 0 do 
	        lamdi:=Random(GF(q));
      end while;
      lamda[i]:=lamdi;
end for;

   
V:=[];            P:=Vq!(E[query_index]);        // query_index:  user's desired index
for i in [1..t] do                               // generate aux: t length-m vectors
      V[i]:= Vq!( [Random(GF(q)):  i in[1..m] ] );        
end for; 
        		// Type(V[i])  ModTupFldElt
       		  // vector is suitable for scalar-multiplication
// _____________________________________query_____________________________________
query:=[];
for i in [1..k] do
      query[i]:=P;
      for j in [1..t] do
            query[i]:=query[i]+lamda[i]^j*V[j];       
      end for;
end for;

tp:=Cputime();  
// _________________________ answer server_1 (s10,s20,s30) _______________________
quy:=[];        quy[1]:= [GF(q)| query[1][i]: i in [1..m] ] ; 
                                   // vector 2 sequence
Fzq:=[];        Fzq[1]:=Evaluate(Fz, quy[1]);         pfq:=[];         pfq[1]:=[];
for j in [1..m] do 
      pfq[1][j]:=Evaluate(Derivative(Fz,j), quy[1]);
end for;
// _________________________ answer server_2 (s11,ss21,s31) ______________________
quy[2]:= [GF(q)| query[2][i]: i in [1..m] ] ;
Fzq[2]:=Evaluate(Fz,quy[2]);       pfq[2]:=[];
for j in [1..m] do 
      pfq[2][j]:=Evaluate(Derivative(Fz,j), quy[2]);
end for;
anstime:=Cputime(tp);    

// __________________________________reconstruction________________________________
Fq<x>:=PolynomialRing(GF(q));    derif:=[];       // set of { f'(lamda_h) }
for h in [1..k] do
      der:=[];
      for io in [1..m] do       
                        //parla:=P[io];            // because t=1;
                        //for i in [1..t] do
                              //parla:=parla+x^i*V[i][io];   // a univariant polynomial
                        //end for;
                        //der[io]:=pfq[h][io]*Evaluate(Derivative(parla),lamda[h]);
            der[io]:=pfq[h][io]*V[1][io];
      end for;
      derif[h]:=&+der;
end for;

coe:=Matrix(GF(q),d*t+1,2*k,[0: i in [1..(d*t+1)*2*k]]);
for i in [1..k] do
for j in [1..d*t+1] do
   if i mod k eq 0 then
      coe[j][i]:=lamda[k]^(j-1);
   else
      coe[j][i]:=lamda[i mod k]^(j-1);
   end if;
end for;
end for;

for i in [k+1..2*k] do
for j in [1..d*t+1] do
   if i mod k eq 0 then
      coe[j][i]:=(j-1)*lamda[k]^(j-2);
   else
      coe[j][i]:=(j-1)*lamda[i mod k]^(j-2);
   end if;
end for;
end for;
                        //Vdt:=VectorSpace(GF(q),d*t);     w:=Vdt!(Fzq cat derif);    
w:=Vector(GF(q), Fzq cat derif);
reo,reg:=Solution(coe,w);

return <reo[1] ,anstime>;
end function;
// ________________________________________________________________________________

		print "finish loading pirwy";
    
    
    
    
    
    
//_________________________________________________________________________________
                                                                    // iteration for variable size of database    					   
w:=256;          itrivial := 7;                                     //using the trivial scheme when n \leq 148;  2^7 =128

for npower in [13..20] do
     print "__________________the following results are with n=2^%o", npower;  
     n:=2^npower;                       
     PrintFile("utime_pirwy.txt","when n=2^" cat IntegerToString(npower));
     PrintFile("stime_pirwy.txt","when n=2^" cat IntegerToString(npower)); 
     PrintFile("vtime_pirwy.txt","when n=2^" cat IntegerToString(npower)); 
     PrintFile("ptime_pirwy.txt","when n=2^" cat IntegerToString(npower)); 
// ________________________________________________________________________________
		//x:=[ [1: i in [1..w]] :i in [1..n] ];   
x:=[ 2^w : i in [1..n] ];       query_input:=9;   	  // the user's desired index in [0..n-1]
//_______________________________________HASH______________________________________
Lay_num:=Ceiling(Log(2,n));          layer:=Lay_num-1;
HB:=[ []: i in[1..Lay_num-1] ];      HB[Lay_num]:=x;

load "SH6.txt";

while layer gt 0 do
   len:=#HB[layer+1];
   for j in [1..Ceiling(len/2)] do
       str1:=IntegerToString( HB[layer+1,2*j-1] );
       if 2*j le len then                               // in case of n\neq 2^integer
           str2:=IntegerToString( HB[layer+1,2*j] );
           HB[layer,j]:= SH6( StringToInteger(str1 cat str2) );          // both the input and output of SH6(integer) are integers
       else
           HB[layer,j]:= SH6( str1 );
       end if;
   end for;
   layer:= layer - 1; 
end while;
Root:= SH6(  StringToInteger( IntegerToString(HB[1,1]) cat IntegerToString(HB[1,2]) )   );

/_______________________________________TIMING_____________________________________
pre1:=Cputime();
//_________________________________________________________________________________
q:=NextPrime(2^32);       	       FZ:=<>;
for i in [itrivial+1..Lay_num+1] do
        if i ge Lay_num then
		X:=HB[Lay_num];      E:=Eset[Lay_num-1];       z:=FunctionField(GF(q),m_set[Lay_num-1]);   
							  // FuunctionField(GF(p), m) --> Multivariate rational function field of rank m over GF(p)
	else
		X:=HB[i]; 	     E:=Eset[i-1];	       z:=FunctionField(GF(q),m_set[i-1]);	                 
        end if;
        FZ:=Append(FZ, F(z,X,E));                         // pre-processing, generate all the function, stars from itrivial+1
end for;
//_______________________________________________________________________
pretime1:=Cputime(pre1);
PrintFile("ptime_pirwy.txt","time of computing Fz is:");     
PrintFile("ptime_pirwy.txt", pretime1); 
PrintFile("ptime_pirwy.txt","************"); 

//________________________find the involving indices______________________
		//qy:=Reverse(Intseq(query_input, 2, Lay_num));       	  // Reverse 之后： query_input 的二进制表示，高位在前
alpha:=[0: indx in [1..Lay_num+1]];                       // alpha stores these involving indices
    alpha[Lay_num+1]:=query_input;      
    alpha[Lay_num]:= query_input + 1;
    if query_input mod 2 eq 1 then 
	alpha[Lay_num]:= query_input - 1;
    end if;
for j := Lay_num-1 to 1 by -1 do
     alpha[j]:= Floor(alpha[j+1]/2);
end for;

utime1:=Cputime(pre1);
PrintFile("ptime_pirwy.txt","time of finding the involving indices is:");  
PrintFile("utime_pirwy.txt",utime1-pretime1); 
PrintFile("utime_pirwy.txt","************");    delete pret;

//______________________execute the multiserver PIR______________________
	print "begin execute the multiserver PIR";
	
iterations:= 40;                              // 每个n循环40次
for cyc in [1..iterations] do	              // **********iteration**********
Res:=[];       				      // 记录PIR的检索结果  
servertime:=[];       fztime:=[];  	
		
		
		
ct:=Cputime();  
for itriv in [1..itrivial] do
	Res[itriv]:= HB[itriv,alpha[itriv]+1]; 
end for;

for i in [itrivial+1..Lay_num+1] do
	pre2:=Cputime(); 
        if i ge Lay_num then
                X:= HB[Lay_num];       E:=Eset[Lay_num-1];		
        else
		X:=HB[i]; 	       E:=Eset[i-1];             // i-1: due to Eset stars from log n = 2	
        end if;

        query_index:=alpha[i]+1;       Fz:=FZ[i-itrivial];       // i-itrivial: FZ begins from itrivial+1
        fztime[i-itrivial]:=Cputime(pre2);      delete pre2;     // [prepare time]  finding the involving indices
        
        Rep:=pirwy(query_index,X,E,Fz);         Res[i]:=Rep[1];      
        servertime[i-itrivial]:=Rep[2];         
end for;
                 
//_________________Verification__________________
vft:=Cputime(ct);    
ver:=IntegerToString( Res[Lay_num+1] );         // MonStgElt 
j:=Lay_num;
while j gt 0 do
    tempj:=IntegerToString( Res[j] );    	          // MonStgElt
    if IsOdd(alpha[j]) then
       ver:=SH6(StringToInteger(ver cat tempj) );
    else
       ver:=SH6(StringToInteger(tempj cat ver) );
    end if;
    j:=j-1;
end while;

if  ver eq IntegerToString(Root) then
     print "result",Res[#Res],", pass the verification";
else 
     print "result",Res[#Res],", does NOT pass the verification";
end if;

wholetime:=Cputime(ct);    //****time of query+reconstruction+verification
delete ct;

PrintFile("vtime_pirwy.txt",wholetime-vft); 
ptime:=&+fztime;         stime:=&+servertime;          // *******time of answer       
PrintFile("stime_pirwy.txt",stime);      
PrintFile("ptime_pirwy.txt",ptime); 
PrintFile("utime_pirwy.txt", vft - stime - ptime);

end for;   // end for the  40  iterations
end for;   // end for npower iterations



